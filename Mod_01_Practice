# fibonacci practice
# establishes function. N is the door to the function where we can inject info
def fibonacci01(N, a, b):
    # this is the container for the output
    L = []
    # this while loop iterates, changing the value of L and returning the output
    #so long as L is less than max #
    while len(L) < N:
        a = b
        b = a+b
        L.append(a)
    return(L)

# query prints output to terminal
# fibonacci01(15)


fibonacci01(8, 3, 4)

# def prac


def real_imag_conj(val):
    return val.real, val.imag, val.conjugate()


r, i, c = real_imag_conj(3+4j)
print(r, i, c)


# flexible arguments

def catch_all(*args, **kwargs):
    print("args =", args)
    print("kwargs = ", kwargs)


# issue here - trouble passing to kwargs. Figure this out.
catch_all(5, 10, 20)


# anonymous (lambda) functions
def add(x, y): return x+y


add(1, 52)


# another thing

data = [{'first': 'Guido', 'last': 'Van Rossum', 'YOB': 1956},
        {'first': 'Grace', 'last': 'Hopper',     'YOB': 1906},
        {'first': 'Alan',  'last': 'Turing',     'YOB': 1912}]

sorted(data, key=lambda item: item['first'])

#error handling intro from curriculum

print(Q)

1+'abc'

2/0

L = [1, 2, 3]
L[1000]

try:
    print("this gets executed first")
    x = 4/0
except:
    print("this gets executed only if there is an error")
    x = 4/2

def safe_divide(a, b):
    try:
        return a/b
    except:
            return 1E100
safe_divide(1,0)


raise RuntimeError("my error message")

